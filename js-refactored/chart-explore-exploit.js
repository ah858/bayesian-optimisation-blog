function drawChartExploreExploit() {
  // Random points generator

  const initial_points_chosen = [
    {"x":26.5998,"y":-0.2},
    {"x":32.9,"y":-0.5},
    {"x":42.0,"y":0.25},
    {"x":46.85,"y":0.17}
  ];
  const plot_points = initial_points_chosen.slice(0);

  const selected_point = {"x":44.15, "y":0.27};

  // For true points, duplicate points chosen and add some extra points
  const points_true = initial_points_chosen.slice(0);
  points_true.push({"x":15, "y":0.44});
  points_true.push(selected_point);
  
  // ============================
  // Event listeners for scroll positions
  // ============================


  window.addEventListener("load", (event) => {
    // rootElement = document.querySelector("#button-explore-exploit-1");
    intersectElement1 = document.querySelector("#explore-exploit-naive-point");
    intersectElement2 = document.querySelector("#explore-exploit-show-variance");
    intersectElement3 = document.querySelector("#explore-exploit-show-true");

    createObserver();
  }, false);

  function createObserver() {
    let observer;

    let enterOptions = {
      root: null,
      rootMargin: "0px 0px -60% 0px",
    };

    let exitOptions = {
      root: null,
      rootMargin: "-50% 0px 0px 0px",
    };

    let enterObserver = new IntersectionObserver(handleEnterIntersect, enterOptions);
    enterObserver.observe(intersectElement1);
    enterObserver.observe(intersectElement2);
    enterObserver.observe(intersectElement3);

    let exitObserver = new IntersectionObserver(handleExitIntersect, exitOptions);
    exitObserver.observe(intersectElement1);
    exitObserver.observe(intersectElement2);
    exitObserver.observe(intersectElement3);
  }

  function handleEnterIntersect(entries, observer) {
  entries.forEach((entry) => {
    if ((entry.isIntersecting) && (entry.target.id == "explore-exploit-naive-point")) {
      addNewPoint();
      showElement("#explore-exploit-text1");
    } else if ((entry.isIntersecting) && (entry.target.id == "explore-exploit-show-true")) {
      showUnderlying();
      showElement("#explore-exploit-text2");
    } else if ((entry.isIntersecting) && (entry.target.id == "explore-exploit-show-variance")) {
      showVariance();
      showElement("#explore-exploit-text3");
    }
  });
  }

  function handleExitIntersect(entries, observer) {
  entries.forEach((entry) => {
    if ((entry.isIntersecting) && (entry.target.id == "explore-exploit-naive-point")) {
      removeNewPoint();

      hideElement("#explore-exploit-text1");
    } else if ((entry.isIntersecting) && (entry.target.id == "explore-exploit-show-true")) {
      hideUnderlying();

      hideElement("#explore-exploit-text2");
    } else if ((entry.isIntersecting) && (entry.target.id == "explore-exploit-show-variance")) {
      hideVariance();

      hideElement("#explore-exploit-text3");
    }
  });
  }

  const showElement = function(target_element_id) {
    // let target_element = document.querySelector(target_element_id);
    // target_element.style.opacity = 1;
    d3.select(target_element_id)
    .transition()
    .duration(250)
    .style("opacity", 1);
  }

  const hideElement = function(target_element_id) {
    // let target_element = document.querySelector(target_element_id);
    // target_element.style.opacity = 0;
    d3.select(target_element_id)
    .transition()
    .duration(200)
    .style("opacity", 0);
  }

  // ============================
  // Begin D3 code
  // ============================

  const svg = d3.select("#chart-explore-exploit").append("svg").attr("viewBox", [0, 0, width, height]);

  // Background y grid
  svg.append("g")
    .call(yGrid, height, width);

  svg.append("g")
    .call(xAxis, height, width);
  
  svg.append("g")
    .call(yAxis, height);

  svg.append("g")
    .call(xLabel, height, width);

  svg.append("g")
    .call(yLabel, height);
  
  // ============================
  // Set up shapes for model
  // ============================
  
  // Set up model mean and std deviations
  const modelLine = d3.line()
    .curve(d3.curveBasis)
    .x(d => xscale(d.x))
    .y(d => yscale(d.mean))
  
  const area = d3.area()
    .curve(d3.curveBasis)
    .x(d => xscale(d.x))
    .y0(d => yscale(d.lower))
    .y1(d => yscale(d.upper));
  
  const area2 = d3.area()
    .curve(d3.curveBasis)
    .x(d => xscale(d.x))
    .y0(d => yscale(d.lower2))
    .y1(d => yscale(d.upper2));
  
  // ============================
  // Add model elements to svg
  // ============================
  
  // Model parameters
  const modelMean = svg.append("g")
    .attr("stroke", "black")
    .attr("fill", "transparent");

  const envelope = svg.append("g")
    .attr("stroke", "transparent")
    .attr("fill", "rgba(0,0,100,0.05)");
  
  const envelope2 = svg.append("g")
    .attr("stroke", "transparent")
    .attr("fill", "rgba(0,0,100,0.1)");
  
  const underlyingMean = svg.append("g")
    .attr("stroke", "red")
    .attr("stroke-dasharray", (3, 5))
    .attr("stroke-width", 2)
    .attr("fill", "transparent");
  
  // ============================
  // Add other elements to svg
  // ============================
 
  // Use rect in the background to capture click events and handle point creation
  const backgroundRect = svg.append("rect")
    .attr("width", width)
    .attr("height", height)
    // Transparent "white", a fill is required to capture click events
    .attr("fill", "#fff0");
  
  // Restrict circles to a common group to set attributes collectively and avoid selecting unwanted elements
  const circles = svg.append("g")
    .attr("fill", "black");
  
  // const dist_underlying = conditional_dist_with_confidence_intervals(points_true.map((d) => d.x),
  //                                                   points_true.map((d) => d.y),
  //                                                   xtilde,
  //                                                   kernel);
 
  // Initial drawing  
  update();

  // ============================
  // Event Listeners for buttons
  // ============================

  // d3.select("#button-explore-exploit-1")
  //   .on("click", (event) => drawNewPoint());

  // d3.select("#button-explore-exploit-2")
  //   .on("click", (event) => showVariance());

  // d3.select("#button-explore-exploit-3")
  //   .on("click", (event) => showUnderlying());
  
  function update() {
  
    // Draw new circles
    circles.selectAll("circle")
      .data(plot_points)
      .join(
        // Special handling for new elements only
        enter => enter.append("circle")
          .attr("r", 7)
      )
      // Applies to merged selection of new and old elements
      .attr("cx", d => xscale(d.x))
      .attr("cy", d => yscale(d.y));
    
    // Update conditional dist
    const dist = conditional_dist_with_confidence_intervals(initial_points_chosen.map((d) => d.x),
                                          initial_points_chosen.map((d) => d.y),
                                          xtilde,
                                          kernel);
    
    modelMean.selectAll('.mean')
      .data([dist])
      .join('path')
      .attr('class', 'mean')
      .attr('d', d => modelLine(d));
    
    // Notify observable that the points have changed
    svg.dispatch("input");
  }
  
  const addNewPoint = function() {
    // Only add the new point if the original 6 points exist
    if (plot_points.length == initial_points_chosen.length) {
      plot_points.push(selected_point);
    }
    drawNewPoint();
  }

  const drawNewPoint = function () {
    // Draw new circles
    circles.selectAll("circle")
      .data(plot_points)
      .join(
        // Special handling for new elements only
        enter => enter.append("circle")
          .attr("r", 7)
          .attr("fill", "red")
      )
      // Applies to merged selection of new and old elements
      .attr("cx", d => xscale(d.x))
      .attr("cy", d => yscale(d.y))
      // .transition()
      // .duration(200)
      // .attrTween('r', () => {
      //   return function(t) { return 7*t - t*(1-t)*15; };
      // });
  }

  const removeNewPoint = function() {
    // Do not alter if only the original 6 points exist
    if (plot_points.length > initial_points_chosen.length) {
      plot_points.pop()
    }

    drawNewPoint();
  }


  const VARIANCE_TRANSITION_DURATION = 350;
  

  const showVariance = function() {
    const dist = conditional_dist_with_confidence_intervals(initial_points_chosen.map((d) => d.x),
                                          initial_points_chosen.map((d) => d.y),
                                          xtilde,
                                          kernel);
  
    modelMean.selectAll('.mean')
      .data([dist])
      .join('path')
      .attr('class', 'mean')
      .attr('d', d => modelLine(d));
    
    envelope.selectAll('.envelope')
      .data([dist])
      .join('path')
      .attr('class', 'envelope')
      .transition()
      .duration(VARIANCE_TRANSITION_DURATION)
      .attr("opacity", 1)
      .attr('d', d => area(d));
    
    envelope2.selectAll('.envelope2')
      .data([dist])
      .join('path')
      .attr('class', 'envelope2')
      .transition()
      .duration(VARIANCE_TRANSITION_DURATION)
      .attr("opacity", 1)
      .attr('d', d => area2(d));
  }

  const hideVariance = function() {

    envelope.selectAll('.envelope')
      .transition()
      .duration(VARIANCE_TRANSITION_DURATION)
      .attr("opacity", 0);
    envelope2.selectAll('.envelope2')
      .transition()
      .duration(VARIANCE_TRANSITION_DURATION)
      .attr("opacity", 0);

  }
  
  const showUnderlying = function() {
    const underlying_dist = conditional_dist_with_confidence_intervals(points_true.map((d) => d.x),
                                          points_true.map((d) => d.y),
                                          xtilde,
                                          kernel);
    
    underlyingMean.selectAll('.underlyingMean')
      .data([underlying_dist])
      .join('path')
      .attr('class', 'underlyingMean')
      .transition()
      .duration(250)
      .attr("opacity", 1)
      .attr('d', d => modelLine(d));
    
    // backgroundRect.on("click", "null");  
  }


  const hideUnderlying = function() {

    console.log("hideUnderlying called")
    underlyingMean.selectAll('.underlyingMean')
      .transition()
      .duration(250)
      .attr("opacity", 0);

  }
  
}

drawChartExploreExploit() 