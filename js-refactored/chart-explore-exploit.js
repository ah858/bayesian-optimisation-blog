function drawChartExploreExploit() {
  const initial_points_chosen = [
    { "x": 26.5998, "y": ymin + 0.4 * (ymax - ymin) },
    { "x": 32.9, "y": ymin + 0.25 * (ymax - ymin) },
    { "x": 42.0, "y": ymin + 0.62 * (ymax - ymin) },
    { "x": 46.85, "y": ymin + 0.55 * (ymax - ymin) }
  ];
  const plot_points = initial_points_chosen.slice(0);

  const selected_point = { "x": 44.15, "y": ymin + 0.63 * (ymax - ymin) };
  // const unexplored_area_loc = {"x": 24.15, "y": ymin + 0.5 * (ymax - ymin)};

  // For true points, duplicate points chosen and add some extra points
  const points_true = initial_points_chosen.slice(0);
  points_true.push({ "x": 15, "y": ymin + 0.75 * (ymax - ymin) });
  points_true.push(selected_point);

  // ============================
  // Event listeners for scroll positions
  // ============================


  window.addEventListener("load", (event) => {
    // rootElement = document.querySelector("#button-explore-exploit-1");
    intersectElement1 = document.querySelector("#explore-exploit-naive-point");
    intersectElement2 = document.querySelector("#explore-exploit-show-variance");
    intersectElement3 = document.querySelector("#explore-exploit-show-true");

    createObserver();
  }, false);

  function createObserver() {
    let observer;

    let enterOptions = {
      root: null,
      rootMargin: "0px 0px -50% 0px",
    };

    let exitOptions = {
      root: null,
      rootMargin: "-50% 0px 0px 0px",
    };

    let enterObserver = new IntersectionObserver(handleEnterIntersect, enterOptions);
    enterObserver.observe(intersectElement1);
    enterObserver.observe(intersectElement2);
    enterObserver.observe(intersectElement3);

    let exitObserver = new IntersectionObserver(handleExitIntersect, exitOptions);
    exitObserver.observe(intersectElement1);
    exitObserver.observe(intersectElement2);
    exitObserver.observe(intersectElement3);
  }

  function handleEnterIntersect(entries, observer) {
    entries.forEach((entry) => {
      if ((entry.isIntersecting) && (entry.target.id == "explore-exploit-naive-point")) {
        addNewPoint();
        // Turn the text red
        d3.select("#naive-point-phrase")
          .transition()
          .duration(250)
          .style("color", "#CC0000");
      } else if ((entry.isIntersecting) && (entry.target.id == "explore-exploit-show-true")) {
        // addUnexploredArea();
        showUnderlying();
        // showElement("#explore-exploit-text2");
      } else if ((entry.isIntersecting) && (entry.target.id == "explore-exploit-show-variance")) {
        showVariance();
        // showElement("#explore-exploit-text3");
      }
    });
  }

  function handleExitIntersect(entries, observer) {
    entries.forEach((entry) => {
      if ((entry.isIntersecting) && (entry.target.id == "explore-exploit-naive-point")) {
        removeNewPoint();
        d3.select("#naive-point-phrase")
          .transition()
          .duration(250)
          .style("color", "#000000");

        // hideElement("#explore-exploit-text1");
      } else if ((entry.isIntersecting) && (entry.target.id == "explore-exploit-show-true")) {
        // removeUnexploredArea();
        hideUnderlying();

        // hideElement("#explore-exploit-text2");
      } else if ((entry.isIntersecting) && (entry.target.id == "explore-exploit-show-variance")) {
        hideVariance();

        // hideElement("#explore-exploit-text3");
      }
    });
  }

  const showElement = function (target_element_id) {
    // let target_element = document.querySelector(target_element_id);
    // target_element.style.opacity = 1;
    d3.select(target_element_id)
      .transition()
      .duration(250)
      .style("opacity", 1);
  }

  const hideElement = function (target_element_id) {
    // let target_element = document.querySelector(target_element_id);
    // target_element.style.opacity = 0;
    d3.select(target_element_id)
      .transition()
      .duration(200)
      .style("opacity", 0);
  }

  // ============================
  // Begin D3 code
  // ============================

  const svg = d3.select("#chart-explore-exploit").append("svg").attr("viewBox", [0, 0, width, height]);

  // Background y grid
  svg.append("g")
    .call(yGrid, height, width);

  svg.append("g")
    .call(xAxis, height, width);

  svg.append("g")
    .call(yAxis, height);

  svg.append("g")
    .call(xLabel, height, width);

  svg.append("g")
    .call(yLabel, height);

  // ============================
  // Set up shapes for model
  // ============================

  // Set up model mean and std deviations
  const modelLine = d3.line()
    .curve(d3.curveBasis)
    .x(d => xscale(d.x))
    .y(d => yscale(d.mean))

  const area = d3.area()
    .curve(d3.curveBasis)
    .x(d => xscale(d.x))
    .y0(d => yscale(d.lower))
    .y1(d => yscale(d.upper));

  const area2 = d3.area()
    .curve(d3.curveBasis)
    .x(d => xscale(d.x))
    .y0(d => yscale(d.lower2))
    .y1(d => yscale(d.upper2));

  // ============================
  // Add model elements to svg
  // ============================

  // Model parameters
  const modelMean = svg.append("g")
    .attr("stroke", "black")
    .attr("fill", "transparent");

  const envelope = svg.append("g")
    .attr("stroke", "transparent")
    .attr("fill", "rgba(0,0,100,0.05)");

  const envelope2 = svg.append("g")
    .attr("stroke", "transparent")
    .attr("fill", "rgba(0,0,100,0.1)");

  const underlyingMean = svg.append("g")
    .attr("stroke", "red")
    .attr("stroke-dasharray", (3, 5))
    .attr("stroke-width", 2)
    .attr("fill", "transparent");

  // ============================
  // Add other elements to svg
  // ============================

  // Use rect in the background to capture click events and handle point creation
  const backgroundRect = svg.append("rect")
    .attr("width", width)
    .attr("height", height)
    // Transparent "white", a fill is required to capture click events
    .attr("fill", "#fff0");

  // Restrict circles to a common group to set attributes collectively and avoid selecting unwanted elements
  const circles = svg.append("g")
    .attr("fill", "black");

  // const highlight_circles = svg.append("g")
  //   .attr("fill", "#00CC11")
  //   .attr("opacity", 0.5);  // This collection is used exclusively for the "circles" used for visual highlighting of points of interest
  // const dist_underlying = conditional_dist_with_confidence_intervals(points_true.map((d) => d.x),
  //                                                   points_true.map((d) => d.y),
  //                                                   xtilde,
  //                                                   kernel);

  // Initial drawing  
  update();

  // ============================
  // Event Listeners for buttons
  // ============================

  // d3.select("#button-explore-exploit-1")
  //   .on("click", (event) => drawNewPoint());

  // d3.select("#button-explore-exploit-2")
  //   .on("click", (event) => showVariance());

  // d3.select("#button-explore-exploit-3")
  //   .on("click", (event) => showUnderlying());

  function update() {

    // Draw new circles
    circles.selectAll("circle")
      .data(plot_points)
      .join(
        // Special handling for new elements only
        enter => enter.append("circle")
          .attr("r", 7)
      )
      // Applies to merged selection of new and old elements
      .attr("cx", d => xscale(d.x))
      .attr("cy", d => yscale(d.y));

    // Update conditional dist
    const dist = conditional_dist_with_confidence_intervals(initial_points_chosen.map((d) => d.x),
      initial_points_chosen.map((d) => d.y),
      xtilde,
      kernel,
      mean_function);

    modelMean.selectAll('.mean')
      .data([dist])
      .join('path')
      .attr('class', 'mean')
      .attr('d', d => modelLine(d));

    // Notify observable that the points have changed
    svg.dispatch("input");
  }

  const addNewPoint = function () {
    // Only add the new point if the original 6 points exist
    if (plot_points.length == initial_points_chosen.length) {
      plot_points.push(selected_point);
    }
    drawNewPoint();
  }

  const drawNewPoint = function () {
    // Draw new circles
    circles.selectAll("circle")
      .data(plot_points)
      .join(
        // Special handling for new elements only
        enter => enter.append("circle")
          .attr("r", 0)
          .attr("fill", "#CC0000")
      )
      // Applies to merged selection of new and old elements
      .attr("cx", d => xscale(d.x))
      .attr("cy", d => yscale(d.y))
      .transition().duration(200).attr("r", 7)
    // .attrTween('r', () => {
    //   return function(t) { return 7*t - t*(1-t)*15; };
    // });
  }

  // const addUnexploredArea = function() {
  //   // Only add the new point if the original 6 points exist
  //   if (highlight_circles.length == 0) {
  //     highlight_circles.push(unexplored_area_loc);
  //   }
  //   drawHighlightCircles();
  // }
  // const removeUnexploredArea = function() {
  //   // Only add the new point if the original 6 points exist
  //   if (highlight_circles.length > 0) {
  //     highlight_circles.pop();
  //   }
  //   drawHighlightCircles();
  // }


  // const drawHighlightCircles = function () {
  //   // Draw new circles
  //   highlight_circles.selectAll("circle")
  //     .data(highlight_circles)
  //     .join(
  //       // Special handling for new elements only
  //       enter => enter.append("circle")
  //         .attr("r", 30)
  //         // .attr("opacity", 0)
  //     )

  //     // Applies to merged selection of new and old elements
  //     .attr("cx", d => xscale(d.x))
  //     .attr("cy", d => yscale(d.y))
  //     // .transition().duration(250).attr("opacity", 0.5)
  // }

  const removeNewPoint = function () {
    // Do not alter if only the original 6 points exist
    if (plot_points.length > initial_points_chosen.length) {
      plot_points.pop()
    }

    drawNewPoint();
  }


  const VARIANCE_TRANSITION_DURATION = 350;


  const showVariance = function () {
    const dist = conditional_dist_with_confidence_intervals(initial_points_chosen.map((d) => d.x),
      initial_points_chosen.map((d) => d.y),
      xtilde,
      kernel,
      mean_function);

    modelMean.selectAll('.mean')
      .data([dist])
      .join('path')
      .attr('class', 'mean')
      .attr('d', d => modelLine(d));

    envelope.selectAll('.envelope')
      .data([dist])
      .join('path')
      .attr('class', 'envelope')
      .transition()
      .duration(VARIANCE_TRANSITION_DURATION)
      .attr("opacity", 1)
      .attr('d', d => area(d));

    envelope2.selectAll('.envelope2')
      .data([dist])
      .join('path')
      .attr('class', 'envelope2')
      .transition()
      .duration(VARIANCE_TRANSITION_DURATION)
      .attr("opacity", 1)
      .attr('d', d => area2(d));
  }

  const hideVariance = function () {

    envelope.selectAll('.envelope')
      .transition()
      .duration(VARIANCE_TRANSITION_DURATION)
      .attr("opacity", 0);
    envelope2.selectAll('.envelope2')
      .transition()
      .duration(VARIANCE_TRANSITION_DURATION)
      .attr("opacity", 0);

  }

  const showUnderlying = function () {
    const underlying_dist = conditional_dist_with_confidence_intervals(points_true.map((d) => d.x),
      points_true.map((d) => d.y),
      xtilde,
      kernel,
      mean_function);

    underlyingMean.selectAll('.underlyingMean')
      .data([underlying_dist])
      .join('path')
      .attr('class', 'underlyingMean')
      .transition()
      .duration(250)
      .attr("opacity", 1)
      .attr('d', d => modelLine(d));

    // backgroundRect.on("click", "null");  
  }


  const hideUnderlying = function () {

    console.log("hideUnderlying called")
    underlyingMean.selectAll('.underlyingMean')
      .transition()
      .duration(250)
      .attr("opacity", 0);

  }

}

drawChartExploreExploit() 